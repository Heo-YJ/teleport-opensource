{"ast":null,"code":"!function (e, t) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define([], t) : \"object\" == typeof exports ? exports.WebLinksAddon = t() : e.WebLinksAddon = t();\n}(self, () => (() => {\n  \"use strict\";\n\n  var e = {\n      6: (e, t) => {\n        function n(e) {\n          try {\n            const t = new URL(e),\n              n = t.password && t.username ? `${t.protocol}//${t.username}:${t.password}@${t.host}` : t.username ? `${t.protocol}//${t.username}@${t.host}` : `${t.protocol}//${t.host}`;\n            return e.toLocaleLowerCase().startsWith(n.toLocaleLowerCase());\n          } catch (e) {\n            return !1;\n          }\n        }\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.LinkComputer = t.WebLinkProvider = void 0, t.WebLinkProvider = class {\n          constructor(e, t, n, o = {}) {\n            this._terminal = e, this._regex = t, this._handler = n, this._options = o;\n          }\n          provideLinks(e, t) {\n            const n = o.computeLink(e, this._regex, this._terminal, this._handler);\n            t(this._addCallbacks(n));\n          }\n          _addCallbacks(e) {\n            return e.map(e => (e.leave = this._options.leave, e.hover = (t, n) => {\n              if (this._options.hover) {\n                const {\n                  range: o\n                } = e;\n                this._options.hover(t, n, o);\n              }\n            }, e));\n          }\n        };\n        class o {\n          static computeLink(e, t, r, i) {\n            const s = new RegExp(t.source, (t.flags || \"\") + \"g\"),\n              [a, c] = o._getWindowedLineStrings(e - 1, r),\n              l = a.join(\"\");\n            let d;\n            const p = [];\n            for (; d = s.exec(l);) {\n              const e = d[0];\n              if (!n(e)) continue;\n              const [t, s] = o._mapStrIdx(r, c, 0, d.index),\n                [a, l] = o._mapStrIdx(r, t, s, e.length);\n              if (-1 === t || -1 === s || -1 === a || -1 === l) continue;\n              const h = {\n                start: {\n                  x: s + 1,\n                  y: t + 1\n                },\n                end: {\n                  x: l,\n                  y: a + 1\n                }\n              };\n              p.push({\n                range: h,\n                text: e,\n                activate: i\n              });\n            }\n            return p;\n          }\n          static _getWindowedLineStrings(e, t) {\n            let n,\n              o = e,\n              r = e,\n              i = 0,\n              s = \"\";\n            const a = [];\n            if (n = t.buffer.active.getLine(e)) {\n              const e = n.translateToString(!0);\n              if (n.isWrapped && \" \" !== e[0]) {\n                for (i = 0; (n = t.buffer.active.getLine(--o)) && i < 2048 && (s = n.translateToString(!0), i += s.length, a.push(s), n.isWrapped && -1 === s.indexOf(\" \")););\n                a.reverse();\n              }\n              for (a.push(e), i = 0; (n = t.buffer.active.getLine(++r)) && n.isWrapped && i < 2048 && (s = n.translateToString(!0), i += s.length, a.push(s), -1 === s.indexOf(\" \")););\n            }\n            return [a, o];\n          }\n          static _mapStrIdx(e, t, n, o) {\n            const r = e.buffer.active,\n              i = r.getNullCell();\n            let s = n;\n            for (; o;) {\n              const e = r.getLine(t);\n              if (!e) return [-1, -1];\n              for (let n = s; n < e.length; ++n) {\n                e.getCell(n, i);\n                const s = i.getChars();\n                if (i.getWidth() && (o -= s.length || 1, n === e.length - 1 && \"\" === s)) {\n                  const e = r.getLine(t + 1);\n                  e && e.isWrapped && (e.getCell(0, i), 2 === i.getWidth() && (o += 1));\n                }\n                if (o < 0) return [t, n];\n              }\n              t++, s = 0;\n            }\n            return [t, s];\n          }\n        }\n        t.LinkComputer = o;\n      }\n    },\n    t = {};\n  function n(o) {\n    var r = t[o];\n    if (void 0 !== r) return r.exports;\n    var i = t[o] = {\n      exports: {}\n    };\n    return e[o](i, i.exports, n), i.exports;\n  }\n  var o = {};\n  return (() => {\n    var e = o;\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.WebLinksAddon = void 0;\n    const t = n(6),\n      r = /(https?|HTTPS?):[/]{2}[^\\s\"'!*(){}|\\\\\\^<>`]*[^\\s\"':,.!?{}|\\\\\\^~\\[\\]`()<>]/;\n    function i(e, t) {\n      const n = window.open();\n      if (n) {\n        try {\n          n.opener = null;\n        } catch {}\n        n.location.href = t;\n      } else console.warn(\"Opening link blocked as opener could not be cleared\");\n    }\n    e.WebLinksAddon = class {\n      constructor(e = i, t = {}) {\n        this._handler = e, this._options = t;\n      }\n      activate(e) {\n        this._terminal = e;\n        const n = this._options,\n          o = n.urlRegex || r;\n        this._linkProvider = this._terminal.registerLinkProvider(new t.WebLinkProvider(this._terminal, o, this._handler, n));\n      }\n      dispose() {\n        this._linkProvider?.dispose();\n      }\n    };\n  })(), o;\n})());","map":{"version":3,"names":["e","t","exports","module","define","amd","WebLinksAddon","self","n","URL","password","username","protocol","host","toLocaleLowerCase","startsWith","WebLinkProvider","constructor","o","_terminal","_regex","_handler","_options","provideLinks","computeLink","_addCallbacks","map","leave","hover","range","r","i","s","RegExp","source","flags","a","c","_getWindowedLineStrings","l","join","d","p","exec","_mapStrIdx","index","length","h","start","x","y","end","push","text","activate","buffer","active","getLine","translateToString","isWrapped","indexOf","reverse","getNullCell","getCell","getChars","getWidth","LinkComputer","window","open","opener","location","href","console","warn","urlRegex","_linkProvider","registerLinkProvider","dispose"],"sources":["webpack://WebLinksAddon/webpack/universalModuleDefinition","webpack://WebLinksAddon/src/WebLinkProvider.ts","webpack://WebLinksAddon/webpack/bootstrap","webpack://WebLinksAddon/src/WebLinksAddon.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WebLinksAddon\"] = factory();\n\telse\n\t\troot[\"WebLinksAddon\"] = factory();\n})(self, () => {\nreturn ","/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { ILinkProvider, ILink, Terminal, IViewportRange, IBufferLine } from '@xterm/xterm';\n\nexport interface ILinkProviderOptions {\n  hover?(event: MouseEvent, text: string, location: IViewportRange): void;\n  leave?(event: MouseEvent, text: string): void;\n  urlRegex?: RegExp;\n}\n\nexport class WebLinkProvider implements ILinkProvider {\n\n  constructor(\n    private readonly _terminal: Terminal,\n    private readonly _regex: RegExp,\n    private readonly _handler: (event: MouseEvent, uri: string) => void,\n    private readonly _options: ILinkProviderOptions = {}\n  ) {\n\n  }\n\n  public provideLinks(y: number, callback: (links: ILink[] | undefined) => void): void {\n    const links = LinkComputer.computeLink(y, this._regex, this._terminal, this._handler);\n    callback(this._addCallbacks(links));\n  }\n\n  private _addCallbacks(links: ILink[]): ILink[] {\n    return links.map(link => {\n      link.leave = this._options.leave;\n      link.hover = (event: MouseEvent, uri: string): void => {\n        if (this._options.hover) {\n          const { range } = link;\n          this._options.hover(event, uri, range);\n        }\n      };\n      return link;\n    });\n  }\n}\n\nfunction isUrl(urlString: string): boolean {\n  try {\n    const url = new URL(urlString);\n    const parsedBase = url.password && url.username\n      ? `${url.protocol}//${url.username}:${url.password}@${url.host}`\n      : url.username\n        ? `${url.protocol}//${url.username}@${url.host}`\n        : `${url.protocol}//${url.host}`;\n    return urlString.toLocaleLowerCase().startsWith(parsedBase.toLocaleLowerCase());\n  } catch (e) {\n    return false;\n  }\n}\n\nexport class LinkComputer {\n  public static computeLink(y: number, regex: RegExp, terminal: Terminal, activate: (event: MouseEvent, uri: string) => void): ILink[] {\n    const rex = new RegExp(regex.source, (regex.flags || '') + 'g');\n\n    const [lines, startLineIndex] = LinkComputer._getWindowedLineStrings(y - 1, terminal);\n    const line = lines.join('');\n\n    let match;\n    const result: ILink[] = [];\n\n    while (match = rex.exec(line)) {\n      const text = match[0];\n\n      // check via URL if the matched text would form a proper url\n      if (!isUrl(text)) {\n        continue;\n      }\n\n      // map string positions back to buffer positions\n      // values are 0-based right side excluding\n      const [startY, startX] = LinkComputer._mapStrIdx(terminal, startLineIndex, 0, match.index);\n      const [endY, endX] = LinkComputer._mapStrIdx(terminal, startY, startX, text.length);\n\n      if (startY === -1 || startX === -1 || endY === -1 || endX === -1) {\n        continue;\n      }\n\n      // range expects values 1-based right side including, thus +1 except for endX\n      const range = {\n        start: {\n          x: startX + 1,\n          y: startY + 1\n        },\n        end: {\n          x: endX,\n          y: endY + 1\n        }\n      };\n\n      result.push({ range, text, activate });\n    }\n\n    return result;\n  }\n\n  /**\n   * Get wrapped content lines for the current line index.\n   * The top/bottom line expansion stops at whitespaces or length > 2048.\n   * Returns an array with line strings and the top line index.\n   *\n   * NOTE: We pull line strings with trimRight=true on purpose to make sure\n   * to correctly match urls with early wrapped wide chars. This corrupts the string index\n   * for 1:1 backmapping to buffer positions, thus needs an additional correction in _mapStrIdx.\n   */\n  private static _getWindowedLineStrings(lineIndex: number, terminal: Terminal): [string[], number] {\n    let line: IBufferLine | undefined;\n    let topIdx = lineIndex;\n    let bottomIdx = lineIndex;\n    let length = 0;\n    let content = '';\n    const lines: string[] = [];\n\n    if ((line = terminal.buffer.active.getLine(lineIndex))) {\n      const currentContent = line.translateToString(true);\n\n      // expand top, stop on whitespaces or length > 2048\n      if (line.isWrapped && currentContent[0] !== ' ') {\n        length = 0;\n        while ((line = terminal.buffer.active.getLine(--topIdx)) && length < 2048) {\n          content = line.translateToString(true);\n          length += content.length;\n          lines.push(content);\n          if (!line.isWrapped || content.indexOf(' ') !== -1) {\n            break;\n          }\n        }\n        lines.reverse();\n      }\n\n      // append current line\n      lines.push(currentContent);\n\n      // expand bottom, stop on whitespaces or length > 2048\n      length = 0;\n      while ((line = terminal.buffer.active.getLine(++bottomIdx)) && line.isWrapped && length < 2048) {\n        content = line.translateToString(true);\n        length += content.length;\n        lines.push(content);\n        if (content.indexOf(' ') !== -1) {\n          break;\n        }\n      }\n    }\n    return [lines, topIdx];\n  }\n\n  /**\n   * Map a string index back to buffer positions.\n   * Returns buffer position as [lineIndex, columnIndex] 0-based,\n   * or [-1, -1] in case the lookup ran into a non-existing line.\n   */\n  private static _mapStrIdx(terminal: Terminal, lineIndex: number, rowIndex: number, stringIndex: number): [number, number] {\n    const buf = terminal.buffer.active;\n    const cell = buf.getNullCell();\n    let start = rowIndex;\n    while (stringIndex) {\n      const line = buf.getLine(lineIndex);\n      if (!line) {\n        return [-1, -1];\n      }\n      for (let i = start; i < line.length; ++i) {\n        line.getCell(i, cell);\n        const chars = cell.getChars();\n        const width = cell.getWidth();\n        if (width) {\n          stringIndex -= chars.length || 1;\n\n          // correct stringIndex for early wrapped wide chars:\n          // - currently only happens at last cell\n          // - cells to the right are reset with chars='' and width=1 in InputHandler.print\n          // - follow-up line must be wrapped and contain wide char at first cell\n          // --> if all these conditions are met, correct stringIndex by +1\n          if (i === line.length - 1 && chars === '') {\n            const line = buf.getLine(lineIndex + 1);\n            if (line && line.isWrapped) {\n              line.getCell(0, cell);\n              if (cell.getWidth() === 2) {\n                stringIndex += 1;\n              }\n            }\n          }\n        }\n        if (stringIndex < 0) {\n          return [lineIndex, i];\n        }\n      }\n      lineIndex++;\n      start = 0;\n    }\n    return [lineIndex, start];\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport type { Terminal, ITerminalAddon, IDisposable } from '@xterm/xterm';\nimport type { WebLinksAddon as IWebLinksApi } from '@xterm/addon-web-links';\nimport { ILinkProviderOptions, WebLinkProvider } from './WebLinkProvider';\n\n// consider everthing starting with http:// or https://\n// up to first whitespace, `\"` or `'` as url\n// NOTE: The repeated end clause is needed to not match a dangling `:`\n// resembling the old (...)*([^:\"\\'\\\\s]) final path clause\n// additionally exclude early + final:\n// - unsafe from rfc3986: !*'()\n// - unsafe chars from rfc1738: {}|\\^~[]` (minus [] as we need them for ipv6 adresses, also allow ~)\n// also exclude as finals:\n// - final interpunction like ,.!?\n// - any sort of brackets <>()[]{} (not spec conform, but often used to enclose urls)\n// - unsafe chars from rfc1738: {}|\\^~[]`\nconst strictUrlRegex = /(https?|HTTPS?):[/]{2}[^\\s\"'!*(){}|\\\\\\^<>`]*[^\\s\"':,.!?{}|\\\\\\^~\\[\\]`()<>]/;\n\n\nfunction handleLink(event: MouseEvent, uri: string): void {\n  const newWindow = window.open();\n  if (newWindow) {\n    try {\n      newWindow.opener = null;\n    } catch {\n      // no-op, Electron can throw\n    }\n    newWindow.location.href = uri;\n  } else {\n    console.warn('Opening link blocked as opener could not be cleared');\n  }\n}\n\nexport class WebLinksAddon implements ITerminalAddon , IWebLinksApi {\n  private _terminal: Terminal | undefined;\n  private _linkProvider: IDisposable | undefined;\n\n  constructor(\n    private _handler: (event: MouseEvent, uri: string) => void = handleLink,\n    private _options: ILinkProviderOptions = {}\n  ) {\n  }\n\n  public activate(terminal: Terminal): void {\n    this._terminal = terminal;\n    const options = this._options as ILinkProviderOptions;\n    const regex = options.urlRegex || strictUrlRegex;\n    this._linkProvider = this._terminal.registerLinkProvider(new WebLinkProvider(this._terminal, regex, this._handler, options));\n  }\n\n  public dispose(): void {\n    this._linkProvider?.dispose();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}